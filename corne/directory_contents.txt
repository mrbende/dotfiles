# Directory Structure
.
├── build
├── build-firmware.sh
├── build-in-docker.sh
├── build.yaml
├── check-firmware.sh
├── config
│   ├── boards
│   │   └── shields
│   │       └── corne
│   │           └── corne.overlay
│   ├── CMakeLists.txt
│   ├── corne.conf
│   ├── corne.keymap
│   ├── includes
│   │   ├── display_left.dtsi
│   │   └── display_right.dtsi
│   ├── resources
│   │   └── images
│   │       └── waifu.bin
│   └── west.yml
├── directory_contents.txt
├── Dockerfile
├── firmware
└── README.md

10 directories, 15 files

# File Contents


# ===========================================
# FILE: ./build-firmware.sh
# ===========================================

#!/bin/bash
set -e

# Create necessary directories
mkdir -p build firmware

# Build the Docker image if it doesn't exist
if ! docker image inspect zmk-corne-build >/dev/null 2>&1; then
  echo "Building Docker image for ZMK builds..."
  docker build -t zmk-corne-build --build-arg USER_ID=$(id -u) --build-arg GROUP_ID=$(id -g) .
fi

# Run the Docker container
echo "Starting ZMK build process in Docker..."
docker run --rm -it \
  -v "$(pwd)/build:/app/build" \
  -v "$(pwd)/config:/app/config:ro" \
  -v "$(pwd)/build.yaml:/app/build.yaml:ro" \
  -v "$(pwd)/firmware:/app/firmware" \
  zmk-corne-build

echo "Build complete! Firmware files are in the 'firmware' directory."



# ===========================================
# FILE: ./build-in-docker.sh
# ===========================================

#!/bin/bash
set -e
config_dir="/app/config"
timestamp=$(date -u +"%Y%m%d%H%M%S")
mkdir -p /app/firmware

# Parse build.yaml
while IFS=$',' read -r board shield; do
    # Remove quotes if present
    board=${board//\"/}
    shield=${shield//\"/}
    
    echo ""
    echo "-----------------"
    echo "BUILDING FIRMWARE"
    echo "-----------------"
    echo "Board: ${board}"
    echo "Shield: ${shield}"
    echo ""
    
    # Set artifact name and build directory
    artifact_name=${shield//nice_view_adapter /}
    artifact_name=${artifact_name//nice_view_custom /}
    artifact_name=${artifact_name//nice_view /}
    artifact_name=${artifact_name// /-}
    build_dir="/app/build/${artifact_name}-${board}"
    
    # Configure and build using the proper path to ZMK
    if [[ ! -d "$build_dir" ]]; then
        cd /app/zmk
        west build -s app -b "$board" -d "$build_dir" -- \
            -DZMK_CONFIG="$config_dir" -DSHIELD="${shield}"
    else
        cd /app/zmk
        west build -d "$build_dir" -- -DZMK_CONFIG="$config_dir"
    fi
    
    # Copy resulting firmware file
    for extension in uf2 hex bin; do
        artifact="${build_dir}/zephyr/zmk.${extension}"
        if [[ -f "$artifact" ]]; then
            filename="/app/firmware/${timestamp}-${artifact_name}-${board}"
            cp "$artifact" "${filename}.${extension}"
            echo "Created firmware file: ${filename}.${extension}"
            break
        fi
    done
done < <(grep -v '^#' /app/build.yaml | grep -e 'board:' -e 'shield:' | sed 's/.*: //' | sed 'N;s/\n/,/')
echo "Build process completed."



# ===========================================
# FILE: ./build.yaml
# ===========================================

# Corne with nice!nano v2 and Nice!View
---
include:
  - board: nice_nano_v2
    shield: corne_left nice_view_adapter nice_view
  - board: nice_nano_v2
    shield: corne_right nice_view_adapter nice_view



# ===========================================
# FILE: ./check-firmware.sh
# ===========================================

#!/bin/bash

# Check if file is provided
if [ $# -ne 1 ]; then
  echo "Usage: $0 <uf2-file>"
  exit 1
fi

UF2_FILE=$1

# Check if file exists
if [ ! -f "$UF2_FILE" ]; then
  echo "Error: File '$UF2_FILE' not found."
  exit 1
fi

# Check file size is multiple of 512 (UF2 block size) - macOS compatible
FILE_SIZE=$(stat -f%z "$UF2_FILE")
if [ $(($FILE_SIZE % 512)) -ne 0 ]; then
  echo "❌ Invalid: File size ($FILE_SIZE bytes) is not a multiple of 512 bytes"
  exit 1
fi

BLOCKS=$(($FILE_SIZE / 512))
echo "✓ File size is valid: $FILE_SIZE bytes ($BLOCKS blocks)"

# Check magic numbers in the first block
MAGIC1=$(hexdump -s 0 -n 4 -e '1/4 "0x%08x"' "$UF2_FILE")
MAGIC2=$(hexdump -s 4 -n 4 -e '1/4 "0x%08x"' "$UF2_FILE")

if [ "$MAGIC1" != "0x0a324655" ] || [ "$MAGIC2" != "0x9e5d5157" ]; then
  echo "❌ Invalid: Magic numbers not found at start of file"
  echo "  Expected: 0x0a324655 0x9e5d5157"
  echo "  Found:    $MAGIC1 $MAGIC2"
  exit 1
fi

echo "✓ Magic numbers are valid"

# Sample a few random blocks to verify they all have the magic numbers
# This is faster than checking every block for large files
NUM_BLOCKS=$(($FILE_SIZE / 512))
if [ $NUM_BLOCKS -gt 10 ]; then
  echo "Sampling blocks for validity check..."
  
  # Check blocks at different positions (beginning, middle, end)
  for pos in 0 $(($NUM_BLOCKS/2)) $(($NUM_BLOCKS-1)); do
    OFFSET=$(($pos * 512))
    MAGIC1=$(hexdump -s $OFFSET -n 4 -e '1/4 "0x%08x"' "$UF2_FILE")
    MAGIC2=$(hexdump -s $(($OFFSET+4)) -n 4 -e '1/4 "0x%08x"' "$UF2_FILE")
    
    if [ "$MAGIC1" != "0x0a324655" ] || [ "$MAGIC2" != "0x9e5d5157" ]; then
      echo "❌ Invalid: Block $pos has invalid magic numbers"
      echo "  Expected: 0x0a324655 0x9e5d5157"
      echo "  Found:    $MAGIC1 $MAGIC2"
      exit 1
    fi
  done
  echo "✓ Sampled blocks have valid structure"
else
  # For small files, check all blocks
  for ((i=0; i<NUM_BLOCKS; i++)); do
    OFFSET=$(($i * 512))
    MAGIC1=$(hexdump -s $OFFSET -n 4 -e '1/4 "0x%08x"' "$UF2_FILE")
    MAGIC2=$(hexdump -s $(($OFFSET+4)) -n 4 -e '1/4 "0x%08x"' "$UF2_FILE")
    
    if [ "$MAGIC1" != "0x0a324655" ] || [ "$MAGIC2" != "0x9e5d5157" ]; then
      echo "❌ Invalid: Block $i has invalid magic numbers"
      exit 1
    fi
  done
  echo "✓ All blocks have valid structure"
fi

echo "✅ UF2 file appears to be valid"
exit 0



# ===========================================
# FILE: ./config/boards/shields/corne/corne.overlay
# ===========================================

/ {
    chosen {
        zmk,display-left = &left_display_status;
        zmk,display-right = &right_display_status;
    };
};



# ===========================================
# FILE: ./config/CMakeLists.txt
# ===========================================

file(GLOB RESOURCES_FILES ${CMAKE_CURRENT_SOURCE_DIR}/resources/images/*)
target_sources(app PRIVATE ${RESOURCES_FILES})



# ===========================================
# FILE: ./config/corne.conf
# ===========================================

# Basic ZMK settings from your working config
CONFIG_BT_CTLR_TX_PWR_PLUS_8=y
CONFIG_ZMK_KSCAN_DEBOUNCE_PRESS_MS=1
CONFIG_ZMK_KSCAN_DEBOUNCE_RELEASE_MS=10
CONFIG_ZMK_STUDIO=y
CONFIG_ZMK_STUDIO_LOCKING=n

# Display Configuration - based on documentation
CONFIG_ZMK_DISPLAY=y
CONFIG_ZMK_DISPLAY_STATUS_SCREEN_BUILT_IN=n
CONFIG_ZMK_DISPLAY_STATUS_SCREEN_CUSTOM=y

# Use dedicated thread for display updates (prevents slow displays from affecting key scanning)
CONFIG_ZMK_DISPLAY_WORK_QUEUE_DEDICATED=y
CONFIG_ZMK_DISPLAY_DEDICATED_THREAD_STACK_SIZE=2048
CONFIG_ZMK_DISPLAY_DEDICATED_THREAD_PRIORITY=5

# Split keyboard settings (required for displays)
CONFIG_ZMK_SPLIT=y
CONFIG_ZMK_SPLIT_BLE=y



# ===========================================
# FILE: ./config/corne.keymap
# ===========================================

// CORNE KEYMAP //

#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/bt.h>

// Include display configurations
#if CONFIG_ZMK_DISPLAY
#include "includes/display_left.dtsi"
#include "includes/display_right.dtsi"
#endif

/ {
    keymap {
        compatible = "zmk,keymap";

        default_layer {
            // -----------------------------------------------------------------------------------------
            // |  TAB |  Q  |  W  |  E  |  R  |  T  |   |  Y  |  U   |  I  |  O  |  P  | BKSP |
            // | CTRL |  A  |  S  |  D  |  F  |  G  |   |  H  |  J   |  K  |  L  |  ;  |  '   |
            // | SHFT |  Z  |  X  |  C  |  V  |  B  |   |  N  |  M   |  ,  |  .  |  /  | ESC  |
            //                    | GUI | LWR | SPC |   | ENT | RSE  | ALT |
            display-name = "Base";
            bindings = <
                &kp TAB   &kp Q &kp W &kp E &kp R &kp T   &kp Y &kp U  &kp I     &kp O   &kp P    &kp BSPC
                &kp LCTRL &kp A &kp S &kp D &kp F &kp G   &kp H &kp J  &kp K     &kp L   &kp SEMI &kp SQT
                &kp LSHFT &kp Z &kp X &kp C &kp V &kp B   &kp N &kp M  &kp COMMA &kp DOT &kp FSLH &kp ESC
                &kp LGUI &mo 1 &kp SPACE   &kp RET &mo 2 &kp RALT
            >;
        };
        lower_layer {
            // -----------------------------------------------------------------------------------------
            // |  TAB |  1  |  2  |  3  |  4  |  5  |   |  6  |  7  |  8  |  9  |  0  | BKSP |
            // | BTCLR| BT1 | BT2 | BT3 | BT4 | BT5 |   | LFT | DWN |  UP | RGT |     |      |
            // | SHFT |     |     |     |     |     |   |     |     |     |     |     |      |
            //                    | GUI |     | SPC |   | ENT |     | ALT |
            display-name = "Lower";
            bindings = <
                &kp TAB    &kp N1       &kp N2       &kp N3       &kp N4       &kp N5         &kp N6   &kp N7   &kp N8 &kp N9    &kp N0 &kp BSPC
                &bt BT_CLR &bt BT_SEL 0 &bt BT_SEL 1 &bt BT_SEL 2 &bt BT_SEL 3 &bt BT_SEL 4   &kp LEFT &kp DOWN &kp UP &kp RIGHT &trans &trans
                &kp LSHFT  &trans       &trans       &trans       &trans       &trans         &trans   &trans   &trans &trans    &trans &trans
                &kp LGUI     &trans       &kp SPACE      &kp RET  &trans   &kp RALT
            >;
        };

        raise_layer {
            // -----------------------------------------------------------------------------------------
            // |  TAB |  !  |  @  |  #  |  $  |  %  |   |  ^  |  &  |  *  |  (  |  )  | BKSP |
            // | CTRL |     |     |     |     |     |   |  -  |  =  |  [  |  ]  |  \  |  `   |
            // | SHFT |     |     |     |     |     |   |  _  |  +  |  {  |  }  | "|" |  ~   |
            //                    | GUI |     | SPC |   | ENT |     | ALT |
            display-name = "Raise";
            bindings = <
                &kp  TAB  &kp EXCL &kp AT &kp HASH &kp DLLR &kp PRCNT   &kp CARET &kp AMPS  &kp KP_MULTIPLY &kp LPAR &kp RPAR &kp BSPC
                &kp LCTRL &trans   &trans &trans   &trans   &trans      &kp MINUS &kp EQUAL &kp LBKT        &kp RBKT &kp BSLH &kp GRAVE
                &kp LSHFT &trans   &trans &trans   &trans   &trans      &kp UNDER &kp PLUS  &kp LBRC        &kp RBRC &kp PIPE &kp TILDE
                &kp LGUI &trans   &kp SPACE   &kp RET   &trans    &kp RALT
            >;
        };

        extra_1 {
            status = "reserved";
        };

        extra_2 {
            status = "reserved";
        };

        extra_3 {
            status = "reserved";
        };
    };
};



# ===========================================
# FILE: ./config/includes/display_left.dtsi
# ===========================================

/ {
    chosen {
        zmk,display = &nice_view_display;
    };
};

/ {
    left_encoder: encoder_left {
        compatible = "alps,ec11";
        label = "LEFT_ENCODER";
        a-gpios = <&pro_micro 4 (GPIO_ACTIVE_HIGH | GPIO_PULL_UP)>;
        b-gpios = <&pro_micro 5 (GPIO_ACTIVE_HIGH | GPIO_PULL_UP)>;
        resolution = <4>;
        status = "okay";
    };

    sensors {
        compatible = "zmk,keymap-sensors";
        sensors = <&left_encoder>;
    };
};

&nice_view_display {
    status = "okay";
};

/ {
    // Use default Nice!View display - don't try to reference the standard ZMK widgets
    left_display_status: left_display_status {
        compatible = "zmk,display-status-screen";
        label = "LEFT_STATUS_SCREEN";
        status = "okay";
    };
};



# ===========================================
# FILE: ./config/includes/display_right.dtsi
# ===========================================

#include <zephyr/dt-bindings/display/screen_info.h>

/ {
    chosen {
        zmk,display = &nice_view_display;
    };
};

&nice_view_display {
    status = "okay";
};

/ {
    // Define your custom right display status screen
    right_display_status: right_display_status {
        compatible = "zmk,display-status-screen";
        label = "RIGHT_STATUS_SCREEN";
        status = "okay";
        
        waifu_widget: waifu_widget {
            compatible = "zmk,widget-static-image";
            status = "okay";
            image = <&waifu_image>;
        };
    };
    
    // Define the image resource with corrected name
    resources {
        compatible = "zmk,display-resources";
        
        waifu_image: waifu_image {
            compatible = "zmk,display-resource-image";
            width = <128>;
            height = <64>;
            format = <SCREEN_INFO_MONO_VTILE_8>;
            path = "/config/resources/images/waifu.bin";
        };
    };
};



# ===========================================
# FILE: ./config/resources/images/waifu.bin
# ===========================================
binary


# ===========================================
# FILE: ./config/west.yml
# ===========================================

manifest:
  remotes:
    - name: zmkfirmware
      url-base: https://github.com/zmkfirmware
  projects:
    - name: zmk
      remote: zmkfirmware
      revision: main
      import: app/west.yml
  self:
    path: config



# ===========================================
# FILE: ./Dockerfile
# ===========================================

FROM docker.io/zmkfirmware/zmk-build-arm:stable

ARG USER_ID=1000
ARG GROUP_ID=1000

# Create user with specified UID/GID
RUN groupadd -g $GROUP_ID -o zmk && \
    useradd -m -u $USER_ID -g $GROUP_ID -o -s /bin/bash zmk

USER zmk
WORKDIR /app

# Clone ZMK and initialize west workspace
RUN git clone https://github.com/zmkfirmware/zmk.git && \
    cd zmk && \
    west init -l app && \
    west update && \
    west zephyr-export

COPY --chown=zmk:zmk ./build-in-docker.sh /app/build-in-docker.sh
RUN chmod +x /app/build-in-docker.sh

ENTRYPOINT ["/app/build-in-docker.sh"]



# ===========================================
# FILE: ./README.md
# ===========================================



